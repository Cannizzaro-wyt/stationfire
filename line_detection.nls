;; See http://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect
;;counter clockwise method (doesn't consider colinearity)
to-report counter-clockwise [x1 y1 x2 y2 x3 y3]
  ;;returns true if triplet creates counter clockwise angle (uses slopes)
  ;(C.y-A.y) * (B.x-A.x) > (B.y-A.y) * (C.x-A.x)
  report (y3 - y1) * (x2 - x1) > (y2 - y1) * (x3 - x1)
end

to-report intersects [x1 y1 x2 y2 x3 y3 x4 y4]
  ;;DANGER: Doesn't work for colinear segments!!!
  ;ccw(A,C,D) != ccw(B,C,D) and ccw(A,B,C) != ccw(A,B,D)
  report (counter-clockwise x1 y1 x3 y3 x4 y4) != (counter-clockwise x2 y2 x3 y3 x4 y4)
  and (counter-clockwise x1 y1 x2 y2 x3 y3) != (counter-clockwise x1 y1 x2 y2 x4 y4)
end


;;;-------------------------------------------------------------
;;Modified from the intersecting lines example in the Netlogo Models Library.
;;;------------------------------

to-report within? [v v1 v2]  ;;
  report (v <= v1 and v >= v2) or (v <= v2 and v >= v1)
end

;; reports a two-item list of x and y coordinates, or an empty
;; list if no intersection is found
to-report intersection [x1 y1 x2 y2 x3 y3 x4 y4 ]
  ;show "--started--"
  ;show (list x1 y1 x2 y2 x3 y3 x4 y4) 
  let m1 nobody
  let m2 nobody
  if x1 != x2 [set m1 (y2 - y1) / (x2 - x1)]
  if x3 != x4 [set m2 (y4 - y3) / (x4 - x3)]
 
  ;; is t1 vertical? if so, swap the two turtles
  if m1 = nobody
  [
    ifelse m2 = nobody
      [ 
        report false ]
      [ report intersection x3 y3 x4 y4 x1 y1 x2 y2 ]
  ]
  ;; is t2 vertical? if so, handle specially
  if m2 = nobody[
     ;; represent t1 line in slope-intercept form (y=mx+c)
      let c1 y1 - (x1 * m1)
      ;; t2 is vertical so we know x already
      let x x3
      ;; solve for y
      let y m1 * x + c1
      ;; check if intersection point lies on both segments
      if not within? x x1 x2 [ report false ]
      if not within? y y3 y4 [ report false ]
      
      report true
  ]
  ;; now handle the normal case where neither turtle is vertical;
  ;; start by representing lines in slope-intercept form (y=mx+c)
  let c1 y1 - (x1 * m1)
  let c2 y3 - (x3 * m2)
  ;treat collinear lines that are ontop of each other as intersecting
  if m1  = m2 [report c1 = c2 and (within? x1 x3 x4 or within? x2 x3 x4)]
  ;; now solve for x
  
  let x (c2 - c1) / (m1 - m2)
  ;; check if intersection point lies on both segments
  if not within? x x1 x2 [
   
   report false ]
  if not within? x x3 x4 [
   report false ]
  
  report true
end

to-report crossed? [x1 y1 x2 y2 x3 y3 x4 y4]
  if 4 > length remove-duplicates (list (list x1 y1) (list x2 y2) (list x3 y3) (list x4 y4)) ;;checks if any end-points are the same
  [report true]
  

  report ((subtract-headings (towards-coords x1 y1 x2 y2) (towards-coords x1 y1 x3 y3) < 0) xor
  (subtract-headings towards-coords x1 y1 x2 y2 towards-coords x1 y1 x4 y4) < 0)
  and (((subtract-headings towards-coords x3 y3 x4 y4 towards-coords x3 y3 x1 y1) < 0) xor 
  (subtract-headings (towards-coords x3 y3 x4 y4) (towards-coords x3 y3 x2 y2)) < 0)
end

to-report towards-coords [x1 y1 x2 y2]
  let deltax x2 - x1
  let deltay y2 - y1
  if deltax = 0 
  [
    ifelse deltay > 0 
    [ report 0]
    [report 180] 
  ]
  if deltay = 0 
  [
    ifelse deltax > 0
    [report 90]
    [report 270] 
  ]
  report (270 + ((radians-to-degrees pi) + (atan2 (- deltay) deltax))) mod 360
end
;; 2 -> 11.592
;; 1-> 57.2958
;; 1.5 -> 85.9437
to-report radians-to-degrees [rad]
 report rad * (180 / pi)
end
to-report atan2 [y x]
  report heading-to-angle (atan x y)
end
to-report heading-to-angle [ h ]
  report (90 - h) mod 360
end
