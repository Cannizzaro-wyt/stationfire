extensions [table]


to-report A-star [start h goals successors]
  let infinity 10000000
  let closed-set (patch-set)
  show start
  let open-set (patch-set start)
  let came-from table:make
  let gscores table:from-list [(list pid infinity)] of patches
  table:put gscores ([pid] of start) 0
  let fscores table:from-list [(list pid infinity)] of patches
  table:put fscores ([pid] of start) (runresult h start goals)
  let current nobody
  let current-pcolor 20
  while [count open-set > 0] ;while open set is not empty
  [
    set current min-one-of open-set [table:get fscores pid] ; current := the node in openSet having the lowest fScore[] value
    let current-pid [pid] of current 
    
    if (any? goals with [pid = current-pid])  [ ;if current = goal
      show "true" ;there's a path
      ask current [set pcolor pink]
      report true]
    set open-set open-set with [pid != current-pid] ;;remove current from open set
    set closed-set (patch-set closed-set current)   ; add current to closed set
    ask current [ set pcolor current-pcolor]
    set current-pcolor current-pcolor + 1
    foreach [self] of (runresult successors current) ;neighbor of current
    [ [neighbor] ->
      let neighbor-pid [pid] of neighbor
      ifelse (any? closed-set with [pid = neighbor-pid]) [];;continue to next neighbor
        [
          let tentative-gscore (table:get gscores current-pid) + 1 ;;1 is dist_between current and neighbor
          if not (any? open-set with [pid = neighbor-pid]) 
          [set open-set (patch-set open-set neighbor)] ;;add new node to open-set
                                                       ;;continue to next neighbor if score isn't good!
          if tentative-gscore < (table:get gscores neighbor-pid) ;update score if better!
          [
            table:put came-from neighbor-pid current-pid
            table:put gscores neighbor-pid tentative-gscore
            table:put fscores neighbor-pid ( (table:get gscores neighbor-pid) + (runresult h neighbor goals))
          ] 
        ]     
      ]
  ] 
  report false
end

;function A*(start, goal)
;    // The set of nodes already evaluated.
;    closedSet := {}
;    // The set of currently discovered nodes that are not evaluated yet.
;    // Initially, only the start node is known.
;    openSet := {start}
;    // For each node, which node it can most efficiently be reached from.
;    // If a node can be reached from many nodes, cameFrom will eventually contain the
;    // most efficient previous step.
;    cameFrom := the empty map
;
;    // For each node, the cost of getting from the start node to that node.
;    gScore := map with default value of Infinity
;    // The cost of going from start to start is zero.
;    gScore[start] := 0
;    // For each node, the total cost of getting from the start node to the goal
;    // by passing by that node. That value is partly known, partly heuristic.
;    fScore := map with default value of Infinity
;    // For the first node, that value is completely heuristic.
;    fScore[start] := heuristic_cost_estimate(start, goal)
;
;    while openSet is not empty
;        current := the node in openSet having the lowest fScore[] value
;        if current = goal
;            return reconstruct_path(cameFrom, current)
;
;        openSet.Remove(current)
;        closedSet.Add(current)
;        for each neighbor of current
;            if neighbor in closedSet
;                continue		// Ignore the neighbor which is already evaluated.
;            // The distance from start to a neighbor
;            tentative_gScore := gScore[current] + dist_between(current, neighbor)
;            if neighbor not in openSet	// Discover a new node
;                openSet.Add(neighbor)
;            else if tentative_gScore >= gScore[neighbor]
;                continue		// This is not a better path.
;
;            // This path is the best until now. Record it!
;            cameFrom[neighbor] := current
;            gScore[neighbor] := tentative_gScore
;            fScore[neighbor] := gScore[neighbor] + heuristic_cost_estimate(neighbor, goal)
;
;    return failure
;
;function reconstruct_path(cameFrom, current)
;    total_path := [current]
;    while current in cameFrom.Keys:
;        current := cameFrom[current]
;        total_path.append(current)
;    return total_path

; node              current node
; g                 the cost to reach current node
; f                 estimated cost of the cheapest path (root..node..goal)
; h(node)           estimated cost of the cheapest path (node..goal)
; cost(node, succ)  step cost function
; is_goal(node)     goal test
; successors(node)  node expanding function, expand nodes ordered by g + h(node)
;

to-report uniform-cost [start goals successors]
  let node start
  let cost 0
  let frontier (list start)
  let explored (list)
  while [not (empty? frontier)]
  [
    set node (first frontier)
    set frontier (bf frontier)
    ask node [set pcolor 20 + cost ]
    set cost cost + 1
    if (any? goals with [pid = [pid] of node]) 
    [report true]
    set explored (lput node explored)
    foreach [self] of (runresult successors node) ;neighbor of current
    [ [neighbor] ->
      if not (member? neighbor (sentence frontier explored))
      [set frontier lput neighbor frontier] ;;distance = cost. so appending at end maintains priority queue.
    ]  
  ]
  report false
end
;procedure UniformCostSearch(Graph, start, goal)
;  node ← start
;  cost ← 0
;  frontier ← priority queue containing node only
;  explored ← empty set
;  do
;    if frontier is empty
;      return failure
;    node ← frontier.pop()
;    if node is goal
;      return solution
;    explored.add(node)
;    for each of node's neighbors n
;      if n is not in explored or frontier
;          frontier.add(n)
;      else if n is in frontier with higher cost
;          replace existing node with n









; procedure ida_star(root)
;   bound := h(root)
;   loop
;     t := search(root, 0, bound)
;     if t = FOUND then return bound
;     if t = ∞ then return NOT_FOUND
;     bound := t
;   end loop
; end procedure
;to-report ida-star [root h successors cost goals]
;  let bound (runresult h root goals)
;  foreach range(60)
;  [[i] ->
;      let t (search root 0 bound h successors cost goals)
;      show (list "ida star" t bound)
;      if t = true [report true]
;      
;      if t != false [set bound t]
;  ]
;  report false
;end
;to-report search [ node g bound h successors cost goals]
;  let f g + (runresult h node goals)
;  if f > bound [report false]
;  if any? goals with [pid = [pid] of node] [report true]
;  let best 1000000
;  foreach [self] of (runresult successors node)
;  [ [succ] ->
;    ask succ [ set pcolor g + 20
;      if pcolor = red [ set pcolor pcolor + 40]
;    ]
;    let t (search succ (g + 1) bound h successors cost goals) ; (runresult cost node succ) = 1
;    if t = true [report true]
;    if t != false and t < best [set best t]
;  ]
;  report best
;end


;
; function search(node, g, bound)
;   f := g + h(node)
;   if f > bound then return f
;   if is_goal(node) then return FOUND
;   min := ∞
;   for succ in successors(node) do
;     t := search(succ, g + cost(node, succ), bound)
;     if t = FOUND then return FOUND
;     if t < min then min := t
;   end for
;   return min
; end function