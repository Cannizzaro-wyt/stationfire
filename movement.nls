to-report valid-next-locations [a-person] ; reports locations that are not walls or fire
  let x1 [xcor] of a-person
  let y1 [ycor] of a-person
  let valid-neighbors (list)
  let n 5 ;Granularity from origin of agent to max height & width
  let max-width 3 ; Area-width (max speed per tick widthwise)
  let max-height 2 ; Area-fixed (max speed per tick heightwise)
  let all-positions  get-grid n max-width max-height x1 y1
  foreach all-positions
  [[pos] ->
    let x2 (first pos)
    let y2 (last pos)

    if patch x2 y2 != nobody and [not any? fires-here with [color = red]] of patch x2 y2 ;;can't have fire (If no fire)
    [
      if not any? ([((turtle-set walls windows) in-radius max-wall-distance ;If no walls or windows if moved to that position
        with [intersection x1 y1 x2 y2 (first first-end) (last first-end) (first second-end) (last second-end)])
      ] of patch x2 y2) [

        set valid-neighbors fput pos valid-neighbors ;possible next location
      ]
    ]
  ]
  report valid-neighbors
end

to-report get-grid [n max-width max-height startx starty]
  let stepx max-width / (2 * n ) ; (2*n) due to full length of grid from origin widthwise
  let stepy max-height / (2 * n) ; (2*n) due to full length of grid from origin heightwise
  let minx startx - n * stepx
  let miny starty - n * stepy
  let maxx startx + n * stepx
  let maxy starty + n * stepy
  let result (list)
  let currx minx
  while [currx <= maxx] ;Creates a list of possible grid points
  [
    let curry miny
    while [curry <= maxy]
    [
      set result fput (list (precision currx 2) (precision curry 2)) result
      set curry curry + stepy
    ]
    set currx currx + stepx
  ]
  report result 
end

to move ;Sets the next location such that it is the minimum distance to the preferred exit
   preferreddirection
  set-f1 goal self
  face goal
  let possible-positions valid-next-locations self 
 ; set possible-positions sort-by [[f] -> f1]  possible-positions
  if not empty? possible-positions 
  [
    let next-pos argmin possible-positions [[pos] -> ([distancexy (first pos) (last pos)] of  goal)] ; bug: people get stuck behind walls
;item 0 possible-positions ; alternate attempt   
    if any? exits with [intersection (first next-pos) (last next-pos) [xcor] of myself [ycor] of myself (first first-end) (last first-end) (first second-end) (last second-end)]
    [
      exit-building]
  setxy (first next-pos) (last next-pos)]
  if goal = nobody [preferreddirection]
end

to-report argmin [alist f] ;Reports the argument that makes the function return minimal
  let min-element (first alist)
  let min-value (runresult f (first alist)) 
  foreach alist
   [ [element] -> 
     if (runresult f element) < min-value 
     [
      set min-element element
      set min-value (runresult f element)  
     ] 
   ]
  report min-element
end

to set-speed-limit ; how fast people can go
  ; units are m/s, from Isobe
  ask people [set speed-limit 1.1 + random-float .2]
end

to set-speed  ; how fast people will go
  ;; count the people on the patch in front of the person
  let people-ahead people in-cone (1 - (1 * smoke)) (210 - (210 * smoke))
  ;; if there are people in front of the person and visible, slow down
  ;; otherwise, speed up
  ifelse any? people-ahead
    [ set speed [speed] of one-of people-ahead
    ]
  [speed-up ]
end

;; decrease the speed of the person
to slow-down  ;; turtle procedure
  ifelse speed <= 0
    [ set speed 0 ]
    [ set speed speed - acceleration ]
end
;; increase the speed of the person
to speed-up  ;; turtle procedure
  ifelse speed > speed-limit
    [ set speed speed-limit ]
    [ set speed speed + acceleration ]
end
to prioritize-group ; dictates when people will stop caring about still-living group members
  ask links with [ [fh] of myself * [group-constant] of myself > threshold] [die] ; as the heuristic rises towards 1, it will eventually hit a threshold, which will be tested
end

to set-group-constant ; allows people to have different values for the degree to which they prioritize their groups, based on group type
  ask people [if group-type = 1 [set group-constant Coworkers-Constant]
    if group-type = 2 [set group-constant Friends-Constant]
    if group-type = 3 [set group-constant Dating-Constant]
  if group-type = 4 [set group-constant Family-Constant]
  if group-type = 5 [set group-constant Multiple-Constant]]
end
